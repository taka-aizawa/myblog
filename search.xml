<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ipコマンドの出力結果（scope、lifetime）</title>
      <link href="/myblog/2024/11/memo-scope-lifetime/"/>
      <url>/myblog/2024/11/memo-scope-lifetime/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tkaizawa.github.io/myblog/memo-localhost-ip-and-loopback/">前回の投稿</a>で<code>ip a</code>コマンドを見た際、ループバックアドレス以外のアドレスの内容も気になり調べた結果をメモしておく。</p><p>例えば、以下のような出力結果について見ていく。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inet 133.xxx.xxx.xxx/24 brd 133.xxx.xxx.255 scope global noprefixroute enp1s0</span><br><span class="line">   valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><br><hr><h1><span id="scopeについて">scopeについて</span></h1><hr><p><a href="https://tkaizawa.github.io/myblog/memo-localhost-ip-and-loopback/">前回の投稿</a>では<code>scope local</code>がローカルホスト内でのみ有効で、外部アクセスはできない設定だと学んだ。<br>    - ex. IPv4の<code>127.0.0.1</code>やIPv6の<code>::1</code>など</p><p>そもそもこの<strong>scope</strong>はIPネットワークの範囲（IPアドレスが有効な範囲、アクセス可能範囲）を表現した概念。</p><p>scopeにはlocalのほかにglobal、linkなどの分類がある（IPv4、IPv6によって定義が異なる）。</p><p><code>scope global</code>：</p><ul><li>グローバルにアクセス可能なアドレス。</li><li>例えば、インターネットにアクセスするための<code>133.xxx.xxx.xxx</code>などのIPv4アドレスなど。</li></ul><p><code>scope link</code>：</p><ul><li>同一リンク（ネットワークインターフェース）上でのみ有効なアドレスで、ルータ等のL3中継装置で区切られたセグメント単位を越えることはできない。</li><li>主にリンクローカルアドレス（IPv6の<code>fe80::/64</code>範囲など）で使用され、隣接デバイスとの直接通信に使われる。</li></ul><p>【参考】<a href="https://www.vwnet.jp/IPv6ImplementationGuide/01/01-11.htm">スコープという考え方</a></p><br><hr><h1><span id="valid_lftについて">valid_lftについて</span></h1><hr><p><code>valid_lft</code>や<code>preferred_lft</code>などはIPアドレスの有効期間（Lifetime）を示している。</p><p><code>valid_lft</code>：</p><ul><li>Valid_Lifetimeの略で、アドレスが有効である期間を秒数で表示する。</li><li><code>forever</code>と表示される場合、アドレスの有効期限が無期限であることを表す。</li><li>この時間が切れるとそのアドレスは無効になり、システムから削除されることがある。</li></ul><p><code>preferred_lft</code>：</p><ul><li>Preferred_Lifetimeの略で、アドレスが優先的に使用される期間を示している。</li><li>この期間内は、システムが他のアドレスよりもこのアドレスを優先して使う。</li></ul><br><hr><h1><span id="出力結果の再見">出力結果の再見</span></h1><hr><p>再度出力結果を見てみる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inet 133.xxx.xxx.xxx/24 brd 133.xxx.xxx.255 scope global noprefixroute enp1s0</span><br><span class="line">   valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><br><p>この例の意味は以下のようになる。</p><p><code>enp1s0</code>：インターフェース名（接続名）<br><code>scope global</code>：グローバルにアクセス可能である<br><code>valid_lft forever preferred_lft forever</code>：このアドレスは無期限に有効で、優先的に使用される</p><p>なお、<code>ip</code>コマンドの内容の見方（<code>ifconfig</code>を使う人もいるが<a href="https://tech.mktime.com/entry/211">非推奨らしい</a>）については、以下の方が素晴らしくまとめて下さっている。<br><a href="https://qiita.com/pe-ta/items/aff8db72530c6baa11b2">ifconfigの出力結果に書いてあること</a></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ローカルホストのipアドレス、ループバックアドレス</title>
      <link href="/myblog/2024/11/memo-localhost-ip-and-loopback/"/>
      <url>/myblog/2024/11/memo-localhost-ip-and-loopback/</url>
      
        <content type="html"><![CDATA[<p><a href="https://it.impress.co.jp/articles/-/26894">IT LeadersのCADDEの記事</a>を読んでいて理解が足りない箇所があり、調べた際のメモ。</p><br><hr><h1><span id="わからなかったこと1">わからなかったこと①</span></h1><hr><p>躓いた箇所はこちら。</p><blockquote><p>ここでは、提供者カタログサイトを5000番ポートで起動しているため、ローカルホストのIPアドレスを指定します。なお、ループバックアドレスやlocalhostを使用すると、提供者コネクタを起動するコンテナ自体を指してしまうことに注意が必要です。ローカルホストのIPアドレスは、Linuxであればip aなどのコマンドから確認できます。<br><br></p></blockquote><p>ローカルホストのIPアドレスは<code>ip a</code>などのコマンドから確認できる、とあったので確認してみたが、沢山出てきてどれがローカルホストのアドレスだかわからなかった。</p><br><hr><h1><span id="調べてわかったこと1">調べてわかったこと①</span></h1><hr><p>Chat-GPT先生に相談しなから調べてみたところ、以下がローカルホストのIPアドレスとのこと。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet 127.0.0.1/8 scope host lo</span><br></pre></td></tr></table></figure><br><p>これがなぜローカルホストのIPだとわかるか？<br><br></p><h3><span id="1-ipアドレスの範囲"><u>1. IPアドレスの範囲</u></span></h3><p><code>127.0.0.1</code>は、IPv4の「<strong>ループバックアドレス</strong>」として特別に予約されているアドレス。<code>127.0.0.1/8</code>という範囲（<code>127.0.0.0</code>から<code>127.255.255.255</code>）はすべて、ループバック用途のみに使用され、外部ネットワークと通信せずに、システム内で自身を指すアドレスとして使われる。<br><br></p><p><strong>ループバックアドレスとは？</strong><br>自分自身を指すIPアドレス。<code>127.0.0.1</code>から<code>127.255.255.255</code>であればいくつでもよい。locakhostも自分自身を指すが、こちらはホスト名のこと。</p><p>ネットワークの標準仕様として、<code>127.0.0.1</code>はlocalhostを指すIPアドレスと定義されており、これはシステム間で共有の設定。</p><p>【参考】<a href="https://qiita.com/miyuki_samitani/items/22eaecd135bf190e45f0">ループバックアドレスとは</a><br>（記事内の参考リンクも合わせて読むと理解が深まる）<br><br></p><h3><span id="2-インターフェース名がlo"><u>2. インターフェース名が「lo」</u></span></h3><p><code>lo</code>は「loopback（ループバック）」の略で、通常どのシステムでも自分自身への通信のための仮想インターフェース（I&#x2F;F）にこの名前が付けられている。このI&#x2F;Fは、<u>システムが外部ネットワークを介さずに自分自身と通信するため</u>に使用される。<br><br></p><h3><span id="3-scope-host"><u>３. scope host</u></span></h3><p><code>scope host</code>は、このアドレスがホスト内にのみ有効であることを示している。外部からアクセスされることはなく、ホスト内の通信にのみ使われる設定。<br><br></p><hr><h1><span id="わからなかったこと2">わからなかったこと②</span></h1><hr><p>ローカルホストのIPアドレスについてはなんとなくわかってきたが、記事の</p><blockquote><p>なお、ループバックアドレスやlocalhostを使用すると、提供者コネクタを起動するコンテナ自体を指してしまうことに注意が必要です。</p></blockquote><p>という文言がよくわからなくなった。</p><p>ローカルホストのIPアドレスを指定するけどlocalhostはNG？<br><br></p><hr><h1><span id="多分わかったこと2">多分わかったこと②</span></h1><hr><p>「ローカルホストに振られているIPアドレスのうち、ループバックアドレス（<code>127.0.0.1</code>）やlocalhostが以外のアドレスを指定しましょう」と解釈した。</p><p>そのため、職場のプライベートクラウド内で使用しているプライベートネットワークのIPアドレスを指定してみる。</p><br>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特定のポートとプロセスについて調べる</title>
      <link href="/myblog/2024/11/memo-linux-lsof/"/>
      <url>/myblog/2024/11/memo-linux-lsof/</url>
      
        <content type="html"><![CDATA[<p>CKANを一旦アンインストールして再インストールしたところ、アンインストール前のユーザ情報・アカウント情報が引き継がれていた。</p><p>これらの情報はどこのファイルを参照しているのかと思い、ポートからプロセスを確認すればよい？？と思いつき、調べ方を確認してみた。</p><p>参考にさせていただいたサイトはこちら。</p><ul><li><a href="https://qiita.com/hypermkt/items/905139168b0bc5c28ef2">lsofコマンド入門</a></li><li><a href="https://qiita.com/kooohei/items/9e3859e3d1d854c3d163">lsofを使ってプロセスが利用しているポートを確認する。</a></li></ul><p>ただ、実際はlsofコマンドを使う必要はなくて、CKANのファイルやディレクトリ構造を調べれば良いだけだった。初心者の回り道ハズカシイ。。。</p><br><hr><h1><span id="lsofコマンド">lsofコマンド</span></h1><hr><p>特定のポートとプロセスの対応関係を調べるには、lsofコマンドを使用する。<br>なお、「lsof」は「list open files」の略とのこと（Wikipedia調べ）。</p><br><hr><h1><span id="調べてみる">調べてみる</span></h1><hr><p><code>localhost:5000</code>のプロセスを調べてみる。<br>（「いやCKANって最初から判っているやん！」というツッコミは後ほど理解した。）</p><br><h3><span id="ポート5000のプロセスを特定"><u>ポート5000のプロセスを特定</u></span></h3><p>「-i:ポート番号」オプションで、指定したポート番号で実行中のプロセスが表示される。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsof -i:5000</span><br></pre></td></tr></table></figure><br><p>上記の出力を見ると、5000番ポートで実行されているプロセスのID（PID）が表示される。<br>今回のPIDは410879だった。</p><br><h3><span id="出力結果のpidから-プロセスがアクセルしているファイルを調べる"><u>出力結果のPIDから、プロセスがアクセルしているファイルを調べる</u></span></h3><p>このPIDをキーにして、プロセスがアクセスしているファイルやディレクトリを確認する。</p><p>「-p」オプションでPIDを指定すると、そのプロレスがアクセスしているファイルが表示できる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lsof -p 410879</span><br><span class="line"></span><br><span class="line">COMMAND      PID USER   FD      TYPE    DEVICE SIZE/OFF      NODE NAME</span><br><span class="line">docker-pr 410879 root  cwd       DIR     253,0      224       128 /</span><br><span class="line">docker-pr 410879 root  rtd       DIR     253,0      224       128 /</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><h3><span id="そういえばdockerでckan動かしてたわ"><u>そういえばDockerでCKAN動かしてたわ、、、</u></span></h3><p>表示内容を見てみると、410879のプロセスはdocker-proxyコマンドで実行されている。つまり、DockerがCKANのプロセスを<code>localhost:5000</code>にポートフォワーディングしている。</p><p>と、ここまで作業してみて、</p><ul><li>そういえばCKANをDockerで実行してたやん、、、</li><li>知りたいのはCKAN内部の参照ファイルなんだから、わざわざポート番号からプロセスを特定しなくてもCKANがユーザ情報やグループ情報を格納しているファイルやディレクトリを調べれば良いやん、、、</li></ul><p>と思い至る。</p><br><h3><span id="chat-gptに聞いてみる"><u>Chat-GPTに聞いてみる</u></span></h3><blockquote><p>Q. CKANの内部フォルダの中で、ユーザグループ情報を格納しているフォルダの名前は何か？</p></blockquote><blockquote><p>A. CKANでは、ユーザグループ情報は主にデータベースに格納されており、特定のフォルダに保存されているわけではありません。ただし、コードやテンプレート、設定ファイルにアクセスしたい場合は、以下のディレクトリが関係しています。</p><p><strong>主に関係するディレクトリ</strong></p><ol><li><p>ckan&#x2F;model<br>model ディレクトリには CKAN の ORM モデル（データベースとのやり取りの仕組み）が含まれています。group.py ファイルには、ユーザグループ（オーガナイゼーションやグループ）のデータ構造が定義されています。</p></li><li><p>ckan&#x2F;logic&#x2F;action<br>action ディレクトリには、グループに関連する API やロジックが含まれており、group.py や &gt; organization.py でユーザグループや組織の操作が実装されています。</p></li><li><p>ckan&#x2F;templates<br>templates フォルダには、ユーザーやグループ情報を表示する HTML テンプレートが含まれており、特に group または organization サブディレクトリが関連するテンプレートです。</p></li></ol><p><strong>データベースとの関連</strong><br>CKAN では、ユーザ、グループ、組織などの情報は PostgreSQL データベース内に格納されます。ユーザグループに関する情報は、主に以下のようなテーブルに保存されています。</p><p>group テーブル: グループ情報を格納<br>member テーブル: ユーザとグループの関係を格納</p></blockquote><br><blockquote><p>Q. rocky linuxでCKANを一度アンインストールして再度インストールしたところ、アンインストール前のグループ情報等が残っていた。これはなぜか？</p></blockquote><blockquote><p>A. CKANをアンインストールしても、設定やデータはデータベースとファイルシステムの別の場所に保存されているため、アンインストール前のデータが残っている可能性があります。以下が考えられる理由です。</p><p><strong>1.データベースのデータが残っている</strong><br>CKANのデータ（グループ、ユーザ、データセットなど）は、通常 PostgreSQL データベースに保存されています。アンインストールしても、データベース自体やその内容は削除されないため、再インストール時に同じデータベースを参照すると、以前のデータがそのまま残っていることになります。</p><p>対策：CKAN のデータベースを削除またはリセットするには、次のような PostgreSQL コマンドを使用してデータベースを削除・再作成する必要があります。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres dropdb ckan_default</span><br><span class="line">sudo -u postgres createdb -O ckan_default ckan_default</span><br></pre></td></tr></table></figure><p><strong>2.storage_path ディレクトリが残っている</strong><br>CKAN の設定ファイル（通常 production.ini）で指定されている storage_path は、ファイルアップロード先のディレクトリです。このフォルダ内には、データセットのファイルやリソースが保存されるため、アンインストールしても削除されません。</p><p>対策：storage_path のフォルダ（通常 &#x2F;var&#x2F;lib&#x2F;ckan&#x2F;default など）を手動で削除することで、アップロードされたファイルやキャッシュが削除されます。</p><p><strong>3. 設定ファイルの残存</strong><br>CKAN の設定ファイル（例：&#x2F;etc&#x2F;ckan&#x2F;default&#x2F;production.ini）が残っている場合もあります。このファイルにはデータベース接続情報が含まれているため、再インストール後も同じデータベースに接続することになります。</p><p>対策：production.ini ファイルを確認し、再インストールの際に新しい設定ファイルを作成するか、データベース設定を変更してください。</p><p>このように、アンインストール後にデータベースやファイルシステムに残っているデータが再インストール時に参照されるため、以前のグループ情報などが残っている可能性が高いです。</p></blockquote><br><h3><span id="別に問題なさそう"><u>別に問題なさそう</u></span></h3><p>上記の回答で、CKANが参照しているフォルダの場所がわかった（&#x2F;etc&#x2F;ckan&#x2F;default&#x2F;や&#x2F;var&#x2F;lib&#x2F;ckan&#x2F;default　など）ので、とりあえず調べるのはここまでにして、何か問題が発生したらもう少し詳しく調べることにした。</p><br>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> コマンド </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSHローカルポートフォワーディング</title>
      <link href="/myblog/2024/11/memo-local-port-forwarding/"/>
      <url>/myblog/2024/11/memo-local-port-forwarding/</url>
      
        <content type="html"><![CDATA[<p>プライベートクラウド上の作業をローカルで確認したい時に使うローカルポートフォワーディングについてのメモ。</p><br><hr><h1><span id="ssh-ローカルポートフォワードとは">SSH ローカルポートフォワードとは</span></h1><hr><blockquote><p>SSH ローカルポートフォワードとは、SSH の接続を通して、ローカルホストの TCP ポートへの接続をリモートホストの TCP ポートに転送する機能です。ポートフォワーディング、トンネリングと呼ばれたりします。</p><p>SSH ローカルポートフォワーディングを利用すると、作業端末から直接接続ができないポートに、SSH により確立された接続を使ってアクセスすることができるようになります。例えば、内部のネットワークのみに公開している Web サイト、データベース、リモートデスクトップに外部から接続したいときなどに使えます。SSH だけ空いていればつながるので、一時的な裏口を作るイメージです。</p></blockquote><p>【参考】<a href="https://www.karakaram.com/notes-on-ssh-local-port-forwarding/">SSHローカルポートフォワードの覚え書き</a><br>（説明がわかりやすい！）</p><br><hr><h1><span id="コマンド">コマンド</span></h1><hr><p>通常のsshコマンドにLオプション（「Local」の意味）と、繋げたいローカルポート・リモートポートを指定する。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh ユーザ名@リモートマシン名 -i .ssh/rsa -L 8080:localhost:80</span><br></pre></td></tr></table></figure><br><p>このとき、</p><ul><li><p><code>ssh ユーザ名@マシン名</code>は、通常のssh接続</p></li><li><p><code>-i .ssh/rsa</code>は、ログインに使う秘密鍵ファイルの指定。</p></li><li><p><code>-L 8080:localhost:80</code>は、ローカルポートフォワーディングの設定。これにより、接続元のローカルマシンのポート8080をリモートマシンのlocalhostポート80に転送して、接続が可能になる。</p></li></ul><br><hr><h1><span id="別のポートフォワーディング">別のポートフォワーディング</span></h1><hr><p>他にリモートポートフォワーディング（オプションは-R）、ダイナミックポートフォワーディングがある。</p><p>【参考】<a href="https://tech-lab.sios.jp/archives/37377">ssh接続のポートフォワーディングは3種類ある！</a></p><p>が、あまり使わないかも？余裕がある時にまた勉強。</p><p>【参考】<a href="https://qiita.com/kazu_ppp/items/55e11b1b64683e3b85a8">SSHポートフォワーディング機能のおさらいと利用例</a></p><br>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wiregurad設定成功メモ</title>
      <link href="/myblog/2024/11/wireguard-setting-success/"/>
      <url>/myblog/2024/11/wireguard-setting-success/</url>
      
        <content type="html"><![CDATA[<p>ようやくwireguardの設定がうまくいったので、メモに残す。<br><br></p><hr><h1><span id="手順">手順</span></h1><hr><!-- toc --><ul><li><a href="#u1-nic%E3%81%AB%E5%9B%BA%E5%AE%9Aip%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%BD%E5%8A%A0u"><u>1. NICに固定IPアドレスを追加</u></a></li><li><a href="#u2-dns%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%A6%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%82%92%E5%AE%9F%E8%A1%8Cu"><u>2. DNSを指定して名前解決を実行</u></a></li><li><a href="#u3-current-dns-server%E3%81%AE%E7%A2%BA%E8%AA%8Du"><u>3. Current DNS Serverの確認</u></a></li><li><a href="#u4-current-dns-server%E3%81%AE%E5%A4%89%E6%9B%B4u"><u>4. Current DNS Serverの変更</u></a></li></ul><!-- tocstop --><h2><span id="1-nicに固定ipアドレスを追加"><u>1. NICに固定IPアドレスを追加</u></span></h2><p>[失敗メモ]（<a href="https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/%EF%BC%89%E3%81%A7%E8%A1%8C%E3%81%A3%E3%81%A6%E3%81%84%E3%81%9F%E3%80%81%E5%9B%BA%E5%AE%9AIP%E3%82%92NIC%E3%81%AB%E8%A8%AD%E5%AE%9A%E3%80%82">https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/）で行っていた、固定IPをNICに設定。</a></p><br><h2><span id="2-dnsを指定して名前解決を実行"><u>2. DNSを指定して名前解決を実行</u></span></h2><p>[失敗メモ]（<a href="https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/%EF%BC%89%E3%81%A7%E3%81%AF%E3%81%93%E3%81%AE%E6%99%82%E7%82%B9%E3%81%A7nslookup%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%8C%E9%80%9A%E3%82%89%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%8C%E3%80%81%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%ABDNS%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%97%E3%81%A6%E8%A9%A6%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D%E3%80%81%E7%84%A1%E4%BA%8B%E5%90%8D%E5%89%8D%E8%A7%A3%E6%B1%BA%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%9F%E3%80%82">https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/）ではこの時点でnslookupコマンドが通らなかったが、明示的にDNSを指定して試してみたところ、無事名前解決ができた。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup xxxxxx 10.250.aaa.aaa</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:xxxxxx</span><br><span class="line">Address: 10.250.b.b</span><br></pre></td></tr></table></figure><br><br><h2><span id="3-current-dns-serverの確認"><u>3. Current DNS Serverの確認</u></span></h2><p>主催者側に質問をしてみたところ、Current DNS Serverが10.250.aaa.aaaになっているか確認するよう指示があり、確認してみる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ resolvectl status</span><br><span class="line"></span><br><span class="line">Global</span><br><span class="line">       Protocols: </span><br><span class="line">resolv.conf mode: </span><br><span class="line"></span><br><span class="line">Link 2 </span><br><span class="line">    Current Scopes: </span><br><span class="line">         Protocols: </span><br><span class="line">Current DNS Server: 136.c.c.c</span><br><span class="line">       DNS Servers: 136.c.c.c 10.250.a.a 8.8.8.8</span><br></pre></td></tr></table></figure><br><p>Current DNS Serverが違っている。<br>ということで、これを10.250.a.aにしてみる。</p><br><h2><span id="4-current-dns-serverの変更"><u>4. Current DNS Serverの変更</u></span></h2><p>Chat-gpt先生に質問してみたところ、以下の手順を教えてくれた。</p><p><strong>1. <code>/etc/systemd/resolved.conf</code>を編集</strong></p><p>resolvectlが管理するDNS設定は<code>/etc/systemd/resolved.conf</code>で設定可能とのこと。</p><p>この<code>resolved.conf</code>の<code>DNS=</code>と<code>FallbackDNS=</code>を設定するよう指示あり。<br>#をコメントアウトして、値を入れる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/systemd/resolved.conf</span><br><span class="line"></span><br><span class="line">[Resolve]</span><br><span class="line">DNS=10.250.a.a</span><br><span class="line">FallbackDNS=8.8.8.8</span><br></pre></td></tr></table></figure><br><p><strong>2.  systemd-resolvedサービスを再起動</strong></p><p>設定を反映させるために、<code>systemd-resolved</code>を再起動。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart systemd-resolved</span><br></pre></td></tr></table></figure><br><p><strong>3. resolvectl statusで確認</strong></p><p>設定が反映されたかどうかを再度reslovectl statusコマンドで確認。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ resolvectl status</span><br><span class="line"></span><br><span class="line">Global</span><br><span class="line">           Protocols: </span><br><span class="line">    resolv.conf mode: </span><br><span class="line">         DNS Servers: 10.250.a.a</span><br><span class="line">Fallback DNS Servers: 8.8.8.8</span><br><span class="line"></span><br><span class="line">Link 2 </span><br><span class="line">Current Scopes: DNS</span><br><span class="line">     Protocols: </span><br><span class="line">   DNS Servers: 136.c.c.c 10.250.a.a 8.8.8.8</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>Current DNS Serverの表示がなくなり、代わりにGlobal側でDNSの値が明示された。</p><br><p><strong>4. nslookup・curlで確認</strong></p><p>この状態でnslookupとcurlを実行してみたところ、特にDNSを指定しなくても疎通できるようになった！</p><br>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireguard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wiregurad設定失敗メモ</title>
      <link href="/myblog/2024/11/wireguard-setting-failure/"/>
      <url>/myblog/2024/11/wireguard-setting-failure/</url>
      
        <content type="html"><![CDATA[<p><a href="https://it.impress.co.jp/category/c320097">某テストベッド</a>に参加するためのネットワーク設定が上手くいかない。</p><p>色々試した記録を残す。</p><br><h2><span id="構成"><u>構成</u></span></h2><p>wireguardを使って主催者側の閉域網（10.250.*.*）に入る。</p><p>参加者はubuntuを2台用意し、1台にwireguardクライアントを入れてルータとして機能させ、もう一台はルータ端末にぶら下がる形でネットワークに接続できるよう設定する。</p><p>２パターンでの接続を試している。</p><ol><li>職場のプライベートクラウドからの接続</li><li>パブリッククラウド（OCI）からの接続</li></ol><br><h2><span id="1-職場のプライベートクラウドからの接続"><u>1. 職場のプライベートクラウドからの接続</u></span></h2><h3><span id="1-1-ルータ端末の設定"><u>1-1. ルータ端末の設定</u></span></h3><p>主催者側のドキュメントに従い、wireguardの設定を進める。<br>事前に受け取っていた.confファイルの中身を一部編集し、wireguardクライアントを起動。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install wireguard</span><br><span class="line"></span><br><span class="line">$ sudo vi /etc/wireguard/wg0.conf #ファイルアクセス権限がない場合はchmod</span><br><span class="line"></span><br><span class="line">$sudo wg-quick up wg0</span><br><span class="line">$sudo systemctl enable wg-quick@wg0</span><br></pre></td></tr></table></figure><br><p>接続確認のためnslookupとcurlを実行したところ、こちらは無事に疎通できた。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; nslookup xxxxxx</span><br><span class="line">Server: 123.456.789.0</span><br><span class="line">Address: 123.456.789.0#0</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name: xxxxxx</span><br><span class="line">Address: 123.456.789.0</span><br><span class="line"></span><br><span class="line">&gt; curl xxxxxx</span><br></pre></td></tr></table></figure><br><h3><span id="1-2-ぶらさがる端末の設定"><u>1-2. ぶらさがる端末の設定</u></span></h3><p>問題はこちら。</p><p><code>/etc/netplan/99-xxxx-xxxx.yaml</code>を作成し、指定の内容で静的ルーティングの設定を行う。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/netplan/99-xxxx-xxxx.yaml</span><br><span class="line"></span><br><span class="line">$ sudo netplan apply</span><br></pre></td></tr></table></figure><br><p>ルータ端末と同じようにnslookupを行うも、疎通できず。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; nslookup xxxxxx</span><br><span class="line">Server: 123.456.789.0</span><br><span class="line">Address: 123.456.789.0#0</span><br><span class="line"></span><br><span class="line">** server can&#x27;t find xxxxxx: NXDOMAIN</span><br></pre></td></tr></table></figure><br><p>pingでどこが通っているか試してみると、ルータ端末のぶら下がり端末の間は疎通できているらしい。</p><p>ということは、ルータ端末のルーティング設定が上手くいっていない？</p><br><h3><span id="試行1ブリッジ用のnicを追加"><u>試行１：ブリッジ用のNICを追加</u></span></h3><p>ブリッジインターフェースと固定IPアドレスを設定して、両端末にインターフェイスを追加してみる。<br>そのために、ルータ側とぶら下がり側の両方に、ブリッジ用の設定ファイル（60-add.yaml）を設置してnetplan applyを実行。</p><p>結果は、、、、インスタンス自体に接続できなくなってしまったヽ(´Д｀;≡;´Д｀)ﾉ</p><p>クラウド管理の御仁に詫びを入れ、コンソールから設定ファイルを削除してもらい、復旧。</p><br><h3><span id="試行21つのnicに複数の固定ipアドレスを設定してみる"><u>試行2：1つのNICに複数の固定IPアドレスを設定してみる</u></span></h3><p>参考にさせていただいたのは<a href="https://qiita.com/rat-engineer755/items/b04e128ee1d2cb4437a5">こちら</a></p><p>まず、cloud-initを無効化のためのファイル作成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg</span><br><span class="line"></span><br><span class="line"># sudo touch /etc/cloud/cloud-init.disabledでも良い？</span><br></pre></td></tr></table></figure><br><p>現在の設定のバックアップ。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp  /etc/netplan/50-cloud-init.yaml ~/50-cloud-init.yaml.bak</span><br></pre></td></tr></table></figure><br><p>NIC設定の編集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/netplan/50-cloud-init.yaml</span><br></pre></td></tr></table></figure><br><p>で、ルータ端末とぶら下がり端末の両方に10.250.x.y.（主催者側から割り当てられたアドレスに対応するもの）を<code>address</code>に追記。</p><p>さらに、外部からのアクセス確保のため、<code>routes:</code>に以下を追記。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes: </span><br><span class="line">              - to:  defalut</span><br><span class="line">                via: aaa.aaa.aaa.aaa </span><br></pre></td></tr></table></figure><br><p>で、設定を適用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netplan apply</span><br></pre></td></tr></table></figure><br>これで再びnslookupを試してみるが、、、、<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** server can&#x27;t find xxxxxx: NXDOMAIN</span><br></pre></td></tr></table></figure><br><p>やっぱりダメ。</p><br><h3><span id="試行3dhcp4-overridesオプションを使用"><u>試行3：<code>dhcp4-overrides</code>オプションを使用</u></span></h3><p>主催者側に相談してみたところ、以下を&#x2F;etc&#x2F;netplan&#x2F;99-xxxx-xxxx.yamlに追記してみてほしいとのこと。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dhcp4-overrides:</span><br><span class="line">    use-dns: false</span><br><span class="line">    use-domains: false</span><br></pre></td></tr></table></figure><br><p>これを追記して、netplan applyからのnslookup。結果は、、、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** server can&#x27;t find xxxxxx: NXDOMAIN</span><br></pre></td></tr></table></figure><br><p>これもダメ。</p><br><h2><span id="2-パブリックトクラウドからの接続"><u>2. パブリックトクラウドからの接続</u></span></h2><p>クラウド管理の御仁に相談したところ、OCIで10.250のプライベートネットワークを組んでubuntuを3台（踏み台＋実機）立ててくださった。大感謝！！</p><p>これでできるのではと、意気揚々とドキュメント通りに作業を進めたところ、、、、</p><p>wireguardのクライアント起動時のエラー（<code>/usr/bin/wg-quick: line 32: resolvconf: command not found</code>）に対処するシンボリックリンク作成コマンドを実行したら、なんとインスタンスが固まってしまい、またsshできなくなる。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /usr/bin/resolvectl /usr/local/bin/resolvconf</span><br></pre></td></tr></table></figure><br><p>またまたコンソールからリンクを削除してもらう羽目に。すみません。</p><p>なかなか環境構築が進まない。。。</p><br>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> wireguard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxのパスワード確認＆変更</title>
      <link href="/myblog/2024/11/linux-passwd/"/>
      <url>/myblog/2024/11/linux-passwd/</url>
      
        <content type="html"><![CDATA[<p>地味だけど大事なのでメモ。</p><p>パスワード確認。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat .passwd</span><br></pre></td></tr></table></figure><br><p>パスワード変更。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd</span><br></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> コマンド </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netplanとsshのメモ</title>
      <link href="/myblog/2024/11/memo-netplan-and-ssh/"/>
      <url>/myblog/2024/11/memo-netplan-and-ssh/</url>
      
        <content type="html"><![CDATA[<p>職場のクラウド環境から外部のプライベート環境に行くための設定でミスったので、備忘のためのメモ。</p><h3><span id="やってしまったこと"><u>やってしまったこと</u></span></h3><p>ubuntuのnetplanにネットワーク設定を追加するyamlファイル（60-xxx.yaml）を置いたところ、sshができなくなってしまった。</p><p>クラウドを管理してくださってる方にお願いして、yamlファイルを削除してもらったところ、無事復旧。</p><br><h3><span id="sshの超初歩ミス"><u>sshの超初歩ミス</u></span></h3><p>その後、別のパブリッククラウドもubuntu2台を構築してもらっているが、アドレスを指定してもアクセスできない。</p><p>と騒いでいたら、ユーザ名を入れていないだけだと分かり赤面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh aizawa@123.456.789.0</span><br></pre></td></tr></table></figure><br><p>踏み台サーバから２台に入るための設定は&#x2F;etc&#x2F;hostsに追記してくださっているので、サーバ名だけ入れれば2台とも入れる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/hosts</span><br><span class="line"></span><br><span class="line">$ ssh cadde-xxx #踏み台サーバに入っている状態で </span><br></pre></td></tr></table></figure><br><p>.ssh&#x2F;configを書けば一発で入れるとのこと。たぶんこういうのだと思うので、後で試してみる。<br><a href="https://qiita.com/miriwo/items/976d21e9a42fd3b01d08">SSH接続先の情報をssh configに記載する</a></p><br>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexoに目次のプラグインを導入</title>
      <link href="/myblog/2024/11/hexo-plugin-toc/"/>
      <url>/myblog/2024/11/hexo-plugin-toc/</url>
      
        <content type="html"><![CDATA[<p>記事レイアウトの微調整。tocというプラグインで目次の自動生成ができるとのこと。</p><br><hr><h1><span id="手順">手順</span></h1><hr><!-- toc --><ul><li><a href="#%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3hexo-toc%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">プラグイン（hexo-toc）のインストール</a></li><li><a href="#icarus%E3%81%AEconfig%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B7%A8%E9%9B%86">Icarusのconfigファイルを編集</a></li><li><a href="#%E8%A8%98%E4%BA%8B%E5%86%85%E3%81%AB%E3%82%BF%E3%82%B0%E3%82%92%E8%A8%AD%E7%BD%AE">記事内にタグを設置</a></li></ul><!-- tocstop --><h3><span id="プラグインhexo-tocのインストール">プラグイン（hexo-toc）のインストール</span></h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-toc --save</span><br></pre></td></tr></table></figure><br><h3><span id="icarusのconfigファイルを編集">Icarusのconfigファイルを編集</span></h3><p>_config.icarus.ymlに以下を追記。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">maxdepth:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">class:</span> <span class="string">toc</span></span><br><span class="line">  <span class="attr">slugify:</span> <span class="string">uslug</span></span><br><span class="line">  <span class="attr">anchor:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">after</span></span><br><span class="line">    <span class="attr">symbol:</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">header-anchor</span></span><br></pre></td></tr></table></figure><br><h3><span id="記事内にタグを設置">記事内にタグを設置</span></h3><p>記事内の目次を表示したい場所に以下のタグを設置。見出しから自動的に目次を出力してくれる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- toc --&gt;</span><br></pre></td></tr></table></figure><br><p>参考にさせていただいた記事は以下。<br><a href="https://fennote.fareastnoise.com/2022/03/04/toc/">HEXO の投稿に目次機能を追加する</a></p><br>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHubのユーザ名を変更</title>
      <link href="/myblog/2024/11/github-username-modify/"/>
      <url>/myblog/2024/11/github-username-modify/</url>
      
        <content type="html"><![CDATA[<p>雑につけたGitHubの名前を変えたくなり、まだ取り返しがつくうちに変更。</p><p>挙動がおかしくなるんじゃないかと不安になりつつ、↓の方の記事をみて多分大丈夫だと思い決行。</p><p><a href="https://qiita.com/plant0322/items/c278ef6d42d096714aa9">適当に付けたGitHubのユーザー名を変えたくなった話</a></p><br><hr><h1><span id="手順">手順</span></h1><hr><!-- toc --><ul><li><a href="#github%E3%81%AB%E3%83%AD%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%97%E3%81%A6%E8%A8%AD%E5%AE%9A%E7%94%BB%E9%9D%A2%E3%81%8B%E3%82%89%E5%A4%89%E6%9B%B4">GitHubにログインして設定画面から変更</a></li><li><a href="#%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E3%81%AEgitconfig%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E7%B7%A8%E9%9B%86">ローカルの.gitconfigファイルを編集</a></li><li><a href="#git%E7%AE%A1%E7%90%86%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E8%A8%AD%E5%AE%9A%E5%A4%89%E6%9B%B4">Git管理のファイルの設定変更</a></li></ul><!-- tocstop --><br><h3><span id="githubにログインして設定画面から変更">GitHubにログインして設定画面から変更</span></h3><p>GitHubにログインして「Setting」→「Account」をクリックする。</p><p>表示された画面の「Change username」をクリックして、出てくるWarningっぽいポップアップの中の<code>I understand, let&#39;s change my username</code>を更にクリック。</p><p>新しいユーザ名を入れるウィンドウが出てくるので、ユーザ名を入力して「Change username」をクリックして完了。</p><br><h3><span id="ローカルのgitconfigファイルを編集">ローカルの.gitconfigファイルを編集</span></h3><p>エディタで直接編集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ subl .gitconfig</span><br><span class="line"></span><br><span class="line">[user]</span><br><span class="line">  name = XXXX</span><br><span class="line">  email = XXXX</span><br></pre></td></tr></table></figure><br><h3><span id="git管理のファイルの設定変更">Git管理のファイルの設定変更</span></h3><p>現状はこのブログのファイルのみがGit管理下。まずリモートリポジトリを確認＆修正。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd myblog</span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote set-url origin 【新しいURL】</span><br></pre></td></tr></table></figure><br><p><code>_config.yml</code>も修正。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url: https://【新しいユーザ名】.github.io/myblog/</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: 【新しいURL】</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure><br>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHubでバックアップ</title>
      <link href="/myblog/2024/11/github-backup/"/>
      <url>/myblog/2024/11/github-backup/</url>
      
        <content type="html"><![CDATA[<p>ブログ立ち上げは無事できたが、現状ではGitHubでホストできているのは公開用データのみで、記事データ（.mdファイル）などはバックアップできていない。</p><p>＃Hexoはフォルダ内のデータから<code>hexo generate</code>コマンドでPublicフォルダを生成し、指定した公開場所（_config.ymlの#Deployment）にデプロイする。</p><p>職場で日頃から「端末は一番大事な時に壊れたりするのでローカルだけで持ってはいけない、必ずクラウドで管理すること」と言われているので、ブログデータ全体をGitHubでバックアップしながらGitHub Pagesにデプロイする方法を検討。</p><br><hr><h1><span id="手順">手順</span></h1><hr><p>main(master)ブランチでバックアップを取りつつ、gh-pagesブランチにデプロイする。<br><br></p><ul><li>Hexoを入れているローカルフォルダをGit管理にする</li><li>コミットする</li><li>ローカルフォルダとGitHubのリモートリポジトリを紐づける</li><li>プッシュする</li><li><code>_config.yml</code>を書き換えてデプロイする</li></ul><br><p>まずはローカルフォルダをGit管理にする。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd myblog</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><br><p>コミットする。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;XXXXX&quot;</span><br></pre></td></tr></table></figure><br><p>GitHubからリモートリポジトリのURLをコピーしてきたら、ローカルと紐づける。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/XXXXX</span><br></pre></td></tr></table></figure><br><p>プッシュする。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>ローカルのメインリポジトリ名をmain、リモートがmasterになっていたせいでブランチが二つできてしまった。。。</p><p>GitHubでデフォルトのブランチをmasterからmainに変更して、masterブランチを削除。</p><p>その後、<code>_config.yml</code>の<code>branch:</code>をmasterからgh-pagesに編集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:XXXXXX.git【GitHubのリポジトリのURL】</span><br><span class="line">  branch: gh-pages #ここをmasterから変更</span><br></pre></td></tr></table></figure><br><p>これまでの作業を保存（add, commit , push）して<code>hexo deploy</code>すると、リモートにgh-pagesブランチが作成される。</p><p>あとはGitHubのPagesの設定（Build and deployment）の「Branch」をgh-pagesブランチに変更すればOK.</p><br>---<p>今後は編集するたびに以下のコマンドを繰り返せばよさそう。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;XXXXX&quot;</span><br><span class="line">$ git push origin main</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><br><p>参考にさせていただいたサイト<br><a href="https://qiita.com/nyu___nS/items/3fca57ce133be69835ba#comments">https://qiita.com/nyu___nS/items/3fca57ce133be69835ba#comments</a></p><br>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ブログ開始</title>
      <link href="/myblog/2024/10/start-blog/"/>
      <url>/myblog/2024/10/start-blog/</url>
      
        <content type="html"><![CDATA[<p>学んだ知識のメモ書きとして、技術ブログの立ち上げを思い立つ。</p><p>QiitaやZennなどのを既存ツールを検討したものの、自由度や視認性の高さなどに惹かれて静的サイトジェネレーターに決めた。テーマはHexoのicarus。</p><p>ホスト先はGitHub Pagesにした。管理が楽だというネットの評判で決めたが、Gitを学び始めて数日の超初心者のため諸々見事にハマり、立ち上げに数日かかった。。。</p><br><hr><h1><span id="手順">手順</span></h1><hr><p>やることは大体こんな感じ。</p><!-- toc --><ul><li><a href="#1-nodejs%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">1. Node.jsのインストール</a></li><li><a href="#2-git%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%A8%E5%88%9D%E6%9C%9F%E8%A8%AD%E5%AE%9A">2. Gitのインストールと初期設定</a></li><li><a href="#3-hexo%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%97%E3%81%A6%E8%B5%B7%E5%8B%95">3. Hexoをインストールして起動</a></li><li><a href="#4-hexo%E3%81%AE%E3%83%86%E3%83%BC%E3%83%9Eicarus%E3%82%92%E5%B0%8E%E5%85%A5">4. Hexoのテーマ（Icarus）を導入</a><ul><li><a href="#%E3%83%8F%E3%83%9E%E3%82%8A%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%881%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E6%96%B9%E6%B3%95%E3%81%8C2%E7%A8%AE%E9%A1%9E%E3%81%82%E3%82%8B">ハマりポイント①：インストール方法が２種類ある</a></li><li><a href="#%E3%83%8F%E3%83%9E%E3%82%8A%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%882_configicarusyml%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8C%E8%A6%8B%E5%BD%93%E3%81%9F%E3%82%89%E3%81%AA%E3%81%84">ハマりポイント②：_config.icarus.ymlファイルが見当たらない</a></li></ul></li><li><a href="#5-github%E3%81%AB%E3%83%97%E3%83%83%E3%82%B7%E3%83%A5%E3%81%97%E3%81%A6pages%E3%81%A7%E5%85%AC%E9%96%8B">5. GitHubにプッシュしてPagesで公開</a><ul><li><a href="#%E3%83%8F%E3%83%9E%E3%82%8A%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%883icarus%E3%81%8Csubmodule%E3%81%A8%E3%81%97%E3%81%A6%E8%AA%8D%E8%AD%98%E3%81%95%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%82%E3%82%8B">ハマりポイント③：icarusがsubmoduleとして認識されることがある</a></li></ul></li><li><a href="#6-%E6%84%9F%E6%83%B3">6. 感想</a></li></ul><!-- tocstop --><br><h2><span id="1-nodejsのインストール">1. Node.jsのインストール</span></h2><hr><p>homebrewでNode.jsをインストール＆確認。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure><br><br><h2><span id="2-gitのインストールと初期設定">2. Gitのインストールと初期設定</span></h2><hr><ul><li>Gitインストール(brew)</li><li>Gitユーザ設定＆メール設定</li><li>GitHubアカウント作成</li><li>GitHubでリポジトリを作成</li></ul><p>ググればたくさん情報が出てくるので省略。</p><br><br><h2><span id="3-hexoをインストールして起動">3. Hexoをインストールして起動</span></h2><hr><p>インストール＆確認。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure><br><p>ローカルにHexoの雛形を作成して、必要なパッケージをインストール。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init myblog</span><br><span class="line">$ cd myblog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><br><p>hexo initコマンドの後ろにファイル名をつければ、ファイルを作成してその中に雛形をデプロイしてくれる。<code>INFO  Start blogging with Hexo!</code>と表示されればOK。</p><p>準備完了。ローカルで一旦立ち上げてみる。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><br><p><code>[info] Hexo is running at https://localhost:4000/. Press Ctrl+C to stop.</code>と表示されるので、localhost:4000にアクセスしてみる。止める時はCtrl+C。</p><br><br><h2><span id="4-hexoのテーマicarusを導入">4. Hexoのテーマ（Icarus）を導入</span></h2><hr><p>自分は3カラムのデザインにしたいと思い、Hexoのテーマを物色。</p><p>色々なデザインテーマが公開されているが、自分がしたいと3カラムのものは意外と少なく、シンプルな感じのIcarusに決定。</p><p>Icarus<br><a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/getting-started-with-icarus/">https://ppoffice.github.io/hexo-theme-icarus/uncategorized/getting-started-with-icarus/</a></p><p>が、このテーマ導入でまずハマる。</p><br><h3><span id="ハマりポイント1インストール方法が2種類ある">ハマりポイント①：インストール方法が２種類ある</span></h3><p>Icarusのインストール方法はgit cloneとnpm経由の２種類があり、それぞれインストールされるフォルダが違う。</p><p>前者はmyblog&#x2F;themesの下にicarusというフォルダ名でインストールされるが、後者はmyblog&#x2F;node_modulesの下にhexo-theme-icarus（とhexo-renderer-inferno）がインストールされる。</p><p>最初にnpmでインストールした後、インストール先がわからずcloneもしてしまった。</p><p>その後にthemesの下のフォルダの方で設定を変更したが、デプロイ後に反映されず、node_modules側を読み込んでいるのだと気づくのに時間がかかった。</p><br><p>自分はnpm経由を選択。「Install via NPM」のタブからコマンドを実行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -S hexo-theme-icarus hexo-renderer-inferno</span><br></pre></td></tr></table></figure><br><p>その後、myblogのフォルダ内にある<code>_config.yml</code>のthemesの項をicarusに変更。</p><p>公式では<code>hexo config theme icarus</code>コマンドが紹介されているが、コマンドを実行したらymlファイルのレイアウトが変わって気持ち悪かったので、手動で対応。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: icarus</span><br></pre></td></tr></table></figure><br><p>ここまでで一旦ローカルで立ち上げ直してみて、Icarusがテーマとして反映されているか確認。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><br><p>localhost:4000を見てみて、テーマが反映されていればOK。</p><br><h3><span id="ハマりポイント2_configicarusymlファイルが見当たらない">ハマりポイント②：_config.icarus.ymlファイルが見当たらない</span></h3><p><code>hexo generate</code>は、静的NTMLをpublicフォルダに生成してくれるコマンド。</p><p>ローカルでの動作確認だけなら<code>hexo server</code>の前に実行する必要はないが、Icarusのデザイン調整を行う<code>_config.icarus.yml</code>ファイルは、<code>hexo generate</code>実行後に生成される。</p><p>このことを知らず、当初<code>hexo generate</code>を実行せずに<code>hexo server</code>だけ実行してローカルで動かしつつデザイン調整をしようとしたため、肝心のymlファイルが見当たらなくて焦った。</p><br><br><h2><span id="5-githubにプッシュしてpagesで公開">5. GitHubにプッシュしてPagesで公開</span></h2><hr><p>エディタで<code>_config.yml</code>を以下のように編集。デプロイの項目は<code>repo:</code>と<code>branch:</code>を追記。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://XXXXXX【ユーザ名】.github.io/XXXXXX【リポジトリ名】/</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:XXXXXX.git【GitHubのリポジトリのURL】</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><br><p>上のURL情報はデプロイに必要か分からないが、一応入れておく。</p><p>これをhexoのコマンドでデプロイするが、Gitへのデプロイヤーが必要なため先に入れておく。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo deploy -g</span><br></pre></td></tr></table></figure><br><p>その後、リポジトリの「Settings」→「Pages」→「Build and deployment」の箇所でBranchを「master」に選択してsave。</p><p>しばらくすると、「Pages」に<code>Your site is live at https://XXXXX</code>という表示が出るので、アクセスしてみて見れればOK。</p><br><h3><span id="ハマりポイント3icarusがsubmoduleとして認識されることがある">ハマりポイント③：icarusがsubmoduleとして認識されることがある</span></h3><p>最初ビルドした際に、エラーが発生して正常に公開できなかった。</p><p>エラーメッセージを見たところ、どうやらicarusをsubmoduleとして認識しているが.gitmoduleファイルに記述が見当たらない、というものらしい（そもそもsubmoduleという概念自体を知らなかったため、ここでもまた理解するのに時間がかかった）。。。</p><p>原因を特定したはいいものの、現存のicarusフォルダをsubmoduleする方法もその後のsubmoduleの管理方法を調べてみても、超初心者にはよくわからない。。。</p><p>よくよく調べてみると、そもそもPagesはデフォルトでJekyllという自動ビルドツールを使っており、このJekyllがicarusをsubmoduleと認識してしまっているっぽい。</p><p><code>.nojekyll</code>という空ファイルをディレクトリ内に置いておくとJekyllの自動ビルドが行われないとのことで、これを試してみたところ無事ビルドされて公開できた。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .nojekyll</span><br></pre></td></tr></table></figure><br><br><h2><span id="6-感想">6. 感想</span></h2><hr><p>主に参考にさせていただいたサイトは以下のとおり。</p><p><a href="https://liginc.co.jp/web/programming/server/104594">https://liginc.co.jp/web/programming/server/104594</a><br><a href="https://qiita.com/ORCHESTRA_TAPE/items/092d1479ff6dcc7e51c2">https://qiita.com/ORCHESTRA_TAPE/items/092d1479ff6dcc7e51c2</a><br><a href="https://tech.qookie.jp/posts/hexo-deploy-github-pages-backup-version/">https://tech.qookie.jp/posts/hexo-deploy-github-pages-backup-version/</a></p><p>Gitに限らず全般的なリテラシー不足なため、諸々初歩的な点で躓いてしまうが、備忘のため恥を忍んで記録に残す。</p><p>＃デザインファイル（hexo-theme-icarus&#x2F;style&#x2F;*.styl）の変更が<code>hexo deploy -g</code>コマンドでもうまく反映できないのが追加課題。。。</p><br><br>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Icarus </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
