{"posts":[{"title":"GitHubでバックアップ","text":"ブログ立ち上げは無事できたが、現状ではGitHubでホストできているのは公開用データのみで、記事データ（.mdファイル）などはバックアップできていない。 ＃Hexoはフォルダ内のデータからhexo generateコマンドでPublicフォルダを生成し、指定した公開場所（_config.ymlの#Deployment）にデプロイする。 職場で日頃から「端末は一番大事な時に壊れたりするのでローカルだけで持ってはいけない、必ずクラウドで管理すること」と言われているので、ブログデータ全体をGitHubでバックアップしながらGitHub Pagesにデプロイする方法を検討。 手順 main(master)ブランチでバックアップを取りつつ、gh-pagesブランチにデプロイする。 Hexoを入れているローカルフォルダをGit管理にする コミットする ローカルフォルダとGitHubのリモートリポジトリを紐づける プッシュする _config.ymlを書き換えてデプロイする まずはローカルフォルダをGit管理にする。 12$ cd myblog$ git init コミットする。 12$ git add .$ git commit -m &quot;XXXXX&quot; GitHubからリモートリポジトリのURLをコピーしてきたら、ローカルと紐づける。 1$ git remote add origin https://github.com/XXXXX プッシュする。 1git push origin main ローカルのメインリポジトリ名をmain、リモートがmasterになっていたせいでブランチが二つできてしまった。。。 GitHubでデフォルトのブランチをmasterからmainに変更して、masterブランチを削除。 その後、_config.ymlのbranch:をmasterからgh-pagesに編集。 1234deploy: type: git repo: git@github.com:XXXXXX.git【GitHubのリポジトリのURL】 branch: gh-pages #ここをmasterから変更 これまでの作業を保存（add, commit , push）してhexo deployすると、リモートにgh-pagesブランチが作成される。 あとはGitHubのPagesの設定（Build and deployment）の「Branch」をgh-pagesブランチに変更すればOK. --- 今後は編集するたびに以下のコマンドを繰り返せばよさそう。 12345$ git add .$ git commit -m &quot;XXXXX&quot;$ git push origin main$ hexo generate$ hexo deploy 参考にさせていただいたサイトhttps://qiita.com/nyu___nS/items/3fca57ce133be69835ba#comments","link":"/myblog/2024/11/github-backup/"},{"title":"ブログ開始","text":"学んだ知識のメモ書きとして、技術ブログの立ち上げを思い立つ。 QiitaやZennなどのを既存ツールを検討したものの、自由度や視認性の高さなどに惹かれて静的サイトジェネレーターに決めた。テーマはHexoのicarus。 ホスト先はGitHub Pagesにした。管理が楽だというネットの評判で決めたが、Gitを学び始めて数日の超初心者のため諸々見事にハマり、立ち上げに数日かかった。。。 手順 やることは大体こんな感じ。 1. Node.jsのインストール 2. Gitのインストールと初期設定 3. Hexoをインストールして起動 4. Hexoのテーマ（Icarus）を導入 ハマりポイント①：インストール方法が２種類ある ハマりポイント②：_config.icarus.ymlファイルが見当たらない 5. GitHubにプッシュしてPagesで公開 ハマりポイント③：icarusがsubmoduleとして認識されることがある 6. 感想 1. Node.jsのインストール homebrewでNode.jsをインストール＆確認。 12$ brew install node$ node -v 2. Gitのインストールと初期設定 Gitインストール(brew) Gitユーザ設定＆メール設定 GitHubアカウント作成 GitHubでリポジトリを作成 ググればたくさん情報が出てくるので省略。 3. Hexoをインストールして起動 インストール＆確認。 12$ sudo npm install hexo-cli -g$ hexo -v ローカルにHexoの雛形を作成して、必要なパッケージをインストール。 123$ hexo init myblog$ cd myblog$ npm install hexo initコマンドの後ろにファイル名をつければ、ファイルを作成してその中に雛形をデプロイしてくれる。INFO Start blogging with Hexo!と表示されればOK。 準備完了。ローカルで一旦立ち上げてみる。 1$ hexo server [info] Hexo is running at https://localhost:4000/. Press Ctrl+C to stop.と表示されるので、localhost:4000にアクセスしてみる。止める時はCtrl+C。 4. Hexoのテーマ（Icarus）を導入 自分は3カラムのデザインにしたいと思い、Hexoのテーマを物色。 色々なデザインテーマが公開されているが、自分がしたいと3カラムのものは意外と少なく、シンプルな感じのIcarusに決定。 Icarushttps://ppoffice.github.io/hexo-theme-icarus/uncategorized/getting-started-with-icarus/ が、このテーマ導入でまずハマる。 ハマりポイント①：インストール方法が２種類あるIcarusのインストール方法はgit cloneとnpm経由の２種類があり、それぞれインストールされるフォルダが違う。 前者はmyblog/themesの下にicarusというフォルダ名でインストールされるが、後者はmyblog/node_modulesの下にhexo-theme-icarus（とhexo-renderer-inferno）がインストールされる。 最初にnpmでインストールした後、インストール先がわからずcloneもしてしまった。 その後にthemesの下のフォルダの方で設定を変更したが、デプロイ後に反映されず、node_modules側を読み込んでいるのだと気づくのに時間がかかった。 自分はnpm経由を選択。「Install via NPM」のタブからコマンドを実行。 1$ npm install -S hexo-theme-icarus hexo-renderer-inferno その後、myblogのフォルダ内にある_config.ymlのthemesの項をicarusに変更。 公式ではhexo config theme icarusコマンドが紹介されているが、コマンドを実行したらymlファイルのレイアウトが変わって気持ち悪かったので、手動で対応。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus ここまでで一旦ローカルで立ち上げ直してみて、Icarusがテーマとして反映されているか確認。 12$ hexo generate$ hexo server localhost:4000を見てみて、テーマが反映されていればOK。 ハマりポイント②：_config.icarus.ymlファイルが見当たらないhexo generateは、静的NTMLをpublicフォルダに生成してくれるコマンド。 ローカルでの動作確認だけならhexo serverの前に実行する必要はないが、Icarusのデザイン調整を行う_config.icarus.ymlファイルは、hexo generate実行後に生成される。 このことを知らず、当初hexo generateを実行せずにhexo serverだけ実行してローカルで動かしつつデザイン調整をしようとしたため、肝心のymlファイルが見当たらなくて焦った。 5. GitHubにプッシュしてPagesで公開 エディタで_config.ymlを以下のように編集。デプロイの項目はrepo:とbranch:を追記。 12345678# URLurl: https://XXXXXX【ユーザ名】.github.io/XXXXXX【リポジトリ名】/# Deploymentdeploy: type: git repo: git@github.com:XXXXXX.git【GitHubのリポジトリのURL】 branch: master 上のURL情報はデプロイに必要か分からないが、一応入れておく。 これをhexoのコマンドでデプロイするが、Gitへのデプロイヤーが必要なため先に入れておく。 12$ npm install hexo-deployer-git --save$ hexo deploy -g その後、リポジトリの「Settings」→「Pages」→「Build and deployment」の箇所でBranchを「master」に選択してsave。 しばらくすると、「Pages」にYour site is live at https://XXXXXという表示が出るので、アクセスしてみて見れればOK。 ハマりポイント③：icarusがsubmoduleとして認識されることがある最初ビルドした際に、エラーが発生して正常に公開できなかった。 エラーメッセージを見たところ、どうやらicarusをsubmoduleとして認識しているが.gitmoduleファイルに記述が見当たらない、というものらしい（そもそもsubmoduleという概念自体を知らなかったため、ここでもまた理解するのに時間がかかった）。。。 原因を特定したはいいものの、現存のicarusフォルダをsubmoduleする方法もその後のsubmoduleの管理方法を調べてみても、超初心者にはよくわからない。。。 よくよく調べてみると、そもそもPagesはデフォルトでJekyllという自動ビルドツールを使っており、このJekyllがicarusをsubmoduleと認識してしまっているっぽい。 .nojekyllという空ファイルをディレクトリ内に置いておくとJekyllの自動ビルドが行われないとのことで、これを試してみたところ無事ビルドされて公開できた。 1$ touch .nojekyll 6. 感想 主に参考にさせていただいたサイトは以下のとおり。 https://liginc.co.jp/web/programming/server/104594https://qiita.com/ORCHESTRA_TAPE/items/092d1479ff6dcc7e51c2https://tech.qookie.jp/posts/hexo-deploy-github-pages-backup-version/ Gitに限らず全般的なリテラシー不足なため、諸々初歩的な点で躓いてしまうが、備忘のため恥を忍んで記録に残す。 ＃デザインファイル（hexo-theme-icarus/style/*.styl）の変更がhexo deploy -gコマンドでもうまく反映できないのが追加課題。。。","link":"/myblog/2024/10/start-blog/"},{"title":"GitHubのユーザ名を変更","text":"雑につけたGitHubの名前を変えたくなり、まだ取り返しがつくうちに変更。 挙動がおかしくなるんじゃないかと不安になりつつ、↓の方の記事をみて多分大丈夫だと思い決行。 適当に付けたGitHubのユーザー名を変えたくなった話 手順 GitHubにログインして設定画面から変更 ローカルの.gitconfigファイルを編集 Git管理のファイルの設定変更 GitHubにログインして設定画面から変更GitHubにログインして「Setting」→「Account」をクリックする。 表示された画面の「Change username」をクリックして、出てくるWarningっぽいポップアップの中のI understand, let's change my usernameを更にクリック。 新しいユーザ名を入れるウィンドウが出てくるので、ユーザ名を入力して「Change username」をクリックして完了。 ローカルの.gitconfigファイルを編集エディタで直接編集。 123456$ cd ~$ subl .gitconfig[user] name = XXXX email = XXXX Git管理のファイルの設定変更現状はこのブログのファイルのみがGit管理下。まずリモートリポジトリを確認＆修正。 123$ cd myblog$ git remote -v$ git remote set-url origin 【新しいURL】 _config.ymlも修正。 123456url: https://【新しいユーザ名】.github.io/myblog/deploy: type: git repo: 【新しいURL】 branch: gh-pages","link":"/myblog/2024/11/github-username-modify/"},{"title":"Hexoに目次のプラグインを導入","text":"記事レイアウトの微調整。tocというプラグインで目次の自動生成ができるとのこと。 手順 プラグイン（hexo-toc）のインストール Icarusのconfigファイルを編集 記事内にタグを設置 プラグイン（hexo-toc）のインストール1$ npm install hexo-toc --save Icarusのconfigファイルを編集_config.icarus.ymlに以下を追記。 12345678toc: maxdepth: 3 class: toc slugify: uslug anchor: position: after symbol: &quot;#&quot; style: header-anchor 記事内にタグを設置記事内の目次を表示したい場所に以下のタグを設置。見出しから自動的に目次を出力してくれる。 1&lt;!-- toc --&gt; 参考にさせていただいた記事は以下。HEXO の投稿に目次機能を追加する","link":"/myblog/2024/11/hexo-plugin-toc/"},{"title":"netplanとsshのメモ","text":"職場のクラウド環境から外部のプライベート環境に行くための設定でミスったので、備忘のためのメモ。 やってしまったことubuntuのnetplanにネットワーク設定を追加するyamlファイル（60-xxx.yaml）を置いたところ、sshができなくなってしまった。 クラウドを管理してくださってる方にお願いして、yamlファイルを削除してもらったところ、無事復旧。 sshの超初歩ミスその後、別のパブリッククラウドもubuntu2台を構築してもらっているが、アドレスを指定してもアクセスできない。 と騒いでいたら、ユーザ名を入れていないだけだと分かり赤面。 1$ ssh aizawa@123.456.789.0 踏み台サーバから２台に入るための設定は/etc/hostsに追記してくださっているので、サーバ名だけ入れれば2台とも入れる。 123$ cat /etc/hosts$ ssh cadde-xxx #踏み台サーバに入っている状態で .ssh/configを書けば一発で入れるとのこと。たぶんこういうのだと思うので、後で試してみる。SSH接続先の情報をssh configに記載する","link":"/myblog/2024/11/memo-netplan-and-ssh/"},{"title":"linuxのパスワード確認＆変更","text":"地味だけど大事なのでメモ。 パスワード確認。 1$ cat .passwd パスワード変更。 1$ passwd","link":"/myblog/2024/11/linux-passwd/"},{"title":"wiregurad設定失敗メモ","text":"某テストベッドに参加するためのネットワーク設定が上手くいかない。 色々試した記録を残す。 構成wireguardを使って主催者側の閉域網（10.250.*.*）に入る。 参加者はubuntuを2台用意し、1台にwireguardクライアントを入れてルータとして機能させ、もう一台はルータ端末にぶら下がる形でネットワークに接続できるよう設定する。 ２パターンでの接続を試している。 職場のプライベートクラウドからの接続 パブリッククラウド（OCI）からの接続 1. 職場のプライベートクラウドからの接続1-1. ルータ端末の設定主催者側のドキュメントに従い、wireguardの設定を進める。事前に受け取っていた.confファイルの中身を一部編集し、wireguardクライアントを起動。 1234567$ sudo apt update$ sudo apt install wireguard$ sudo vi /etc/wireguard/wg0.conf #ファイルアクセス権限がない場合はchmod$sudo wg-quick up wg0$sudo systemctl enable wg-quick@wg0 接続確認のためnslookupとcurlを実行したところ、こちらは無事に疎通できた。 123456789&gt; nslookup xxxxxxServer: 123.456.789.0Address: 123.456.789.0#0Non-authoritative answer:Name: xxxxxxAddress: 123.456.789.0&gt; curl xxxxxx 1-2. ぶらさがる端末の設定問題はこちら。 /etc/netplan/99-xxxx-xxxx.yamlを作成し、指定の内容で静的ルーティングの設定を行う。 123$ sudo vi /etc/netplan/99-xxxx-xxxx.yaml$ sudo netplan apply ルータ端末と同じようにnslookupを行うも、疎通できず。 12345&gt; nslookup xxxxxxServer: 123.456.789.0Address: 123.456.789.0#0** server can't find xxxxxx: NXDOMAIN pingでどこが通っているか試してみると、ルータ端末のぶら下がり端末の間は疎通できているらしい。 ということは、ルータ端末のルーティング設定が上手くいっていない？ 試行１：ブリッジ用のNICを追加ブリッジインターフェースと固定IPアドレスを設定して、両端末にインターフェイスを追加してみる。そのために、ルータ側とぶら下がり側の両方に、ブリッジ用の設定ファイル（60-add.yaml）を設置してnetplan applyを実行。 結果は、、、、インスタンス自体に接続できなくなってしまったヽ(´Д｀;≡;´Д｀)ﾉ クラウド管理の御仁に詫びを入れ、コンソールから設定ファイルを削除してもらい、復旧。 試行2：1つのNICに複数の固定IPアドレスを設定してみる参考にさせていただいたのはこちら まず、cloud-initを無効化のためのファイル作成。 12$ sudo vi /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg# sudo touch /etc/cloud/cloud-init.disabledでも良い？ ↓をファイル内に追記して保存。 1network: {config: disabled} 現在の設定のバックアップ。 1$ cp /etc/netplan/50-cloud-init.yaml ~/50-cloud-init.yaml.bak NIC設定の編集。 1$ vi /etc/netplan/50-cloud-init.yaml で、ルータ端末とぶら下がり端末の両方に10.250.x.y.（主催者側から割り当てられたアドレスに対応するもの）をaddressに追記。 さらに、外部からのアクセス確保のため、routes:に以下を追記。 123routes: - to: defalut via: aaa.aaa.aaa.aaa で、設定を適用。 1$ sudo netplan apply これで再びnslookupを試してみるが、、、、 1** server can't find xxxxxx: NXDOMAIN やっぱりダメ。 試行3：dhcp4-overridesオプションを使用主催者側に相談してみたところ、以下を/etc/netplan/99-xxxx-xxxx.yamlに追記してみてほしいとのこと。 123dhcp4-overrides: use-dns: false use-domains: false これを追記して、netplan applyからのnslookup。結果は、、、 1** server can't find xxxxxx: NXDOMAIN これもダメ。 2. パブリックトクラウドからの接続クラウド管理の御仁に相談したところ、OCIで10.250のプライベートネットワークを組んでubuntuを3台（踏み台＋実機）立ててくださった。大感謝！！ これでできるのではと、意気揚々とドキュメント通りに作業を進めたところ、、、、 wireguardのクライアント起動時のエラー（/usr/bin/wg-quick: line 32: resolvconf: command not found）に対処するシンボリックリンク作成コマンドを実行したら、なんとインスタンスが固まってしまい、またsshできなくなる。。。 1$ sudo ln -s /usr/bin/resolvectl /usr/local/bin/resolvconf またまたコンソールからリンクを削除してもらう羽目に。すみません。 なかなか環境構築が進まない。。。","link":"/myblog/2024/11/wireguard-setting-failure/"},{"title":"wiregurad設定成功メモ","text":"ようやくwireguardの設定がうまくいったので、メモに残す。 手順 1. NICに固定IPアドレスを追加 2. DNSを指定して名前解決を実行 3. Current DNS Serverの確認 4. Current DNS Serverの変更 1. NICに固定IPアドレスを追加[失敗メモ]（https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/）で行っていた、固定IPをNICに設定。 2. DNSを指定して名前解決を実行[失敗メモ]（https://tkaizawa.github.io/myblog/2024/11/wireguard-setting-failure/）ではこの時点でnslookupコマンドが通らなかったが、明示的にDNSを指定して試してみたところ、無事名前解決ができた。 12345$ nslookup xxxxxx 10.250.aaa.aaaNon-authoritative answer:Name: xxxxxxAddress: 10.250.b.b 3. Current DNS Serverの確認主催者側に質問をしてみたところ、Current DNS Serverが10.250.aaa.aaaになっているか確認するよう指示があり、確認してみる。 1234567891011$ resolvectl statusGlobal Protocols: resolv.conf mode: Link 2 Current Scopes: Protocols: Current DNS Server: 136.c.c.c DNS Servers: 136.c.c.c 10.250.a.a 8.8.8.8 Current DNS Serverが違っている。ということで、これを10.250.a.aにしてみる。 4. Current DNS Serverの変更Chat-gpt先生に質問してみたところ、以下の手順を教えてくれた。 1. /etc/systemd/resolved.confを編集 resolvectlが管理するDNS設定は/etc/systemd/resolved.confで設定可能とのこと。 このresolved.confのDNS=とFallbackDNS=を設定するよう指示あり。#をコメントアウトして、値を入れる。 12345$ sudo vi /etc/systemd/resolved.conf[Resolve]DNS=10.250.a.aFallbackDNS=8.8.8.8 2. systemd-resolvedサービスを再起動 設定を反映させるために、systemd-resolvedを再起動。 1$ sudo systemctl restart systemd-resolved 3. resolvectl statusで確認 設定が反映されたかどうかを再度reslovectl statusコマンドで確認。 12345678910111213$ resolvectl statusGlobal Protocols: resolv.conf mode: DNS Servers: 10.250.a.aFallback DNS Servers: 8.8.8.8Link 2 Current Scopes: DNS Protocols: DNS Servers: 136.c.c.c 10.250.a.a 8.8.8.8 Current DNS Serverの表示がなくなり、代わりにGlobal側でDNSの値が明示された。 4. nslookup・curlで確認 この状態でnslookupとcurlを実行してみたところ、特にDNSを指定しなくても疎通できるようになった！","link":"/myblog/2024/11/wireguard-setting-success/"},{"title":"特定のポートとプロセスについて調べる","text":"CKANを一旦アンインストールして再インストールしたところ、アンインストール前のユーザ情報・アカウント情報が引き継がれていた。 これらの情報はどこのファイルを参照しているのかと思い、ポートからプロセスを確認すればよい？？と思いつき、調べ方を確認してみた。 参考にさせていただいたサイトはこちら。 lsofコマンド入門 lsofを使ってプロセスが利用しているポートを確認する。 ただ、実際はlsofコマンドを使う必要はなくて、CKANのファイルやディレクトリ構造を調べれば良いだけだった。初心者の回り道ハズカシイ。。。 lsofコマンド 特定のポートとプロセスの対応関係を調べるには、lsofコマンドを使用する。なお、「lsof」は「list open files」の略とのこと（Wikipedia調べ）。 調べてみる localhost:5000のプロセスを調べてみる。（「いやCKANって最初から判っているやん！」というツッコミは後ほど理解した。） ポート5000のプロセスを特定「-i:ポート番号」オプションで、指定したポート番号で実行中のプロセスが表示される。 1$ sudo lsof -i:5000 上記の出力を見ると、5000番ポートで実行されているプロセスのID（PID）が表示される。今回のPIDは410879だった。 出力結果のPIDから、プロセスがアクセルしているファイルを調べるこのPIDをキーにして、プロセスがアクセスしているファイルやディレクトリを確認する。 「-p」オプションでPIDを指定すると、そのプロレスがアクセスしているファイルが表示できる。 123456$ sudo lsof -p 410879COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEdocker-pr 410879 root cwd DIR 253,0 224 128 /docker-pr 410879 root rtd DIR 253,0 224 128 /... そういえばDockerでCKAN動かしてたわ、、、表示内容を見てみると、410879のプロセスはdocker-proxyコマンドで実行されている。つまり、DockerがCKANのプロセスをlocalhost:5000にポートフォワーディングしている。 と、ここまで作業してみて、 そういえばCKANをDockerで実行してたやん、、、 知りたいのはCKAN内部の参照ファイルなんだから、わざわざポート番号からプロセスを特定しなくてもCKANがユーザ情報やグループ情報を格納しているファイルやディレクトリを調べれば良いやん、、、 と思い至る。 Chat-GPTに聞いてみる Q. CKANの内部フォルダの中で、ユーザグループ情報を格納しているフォルダの名前は何か？ A. CKANでは、ユーザグループ情報は主にデータベースに格納されており、特定のフォルダに保存されているわけではありません。ただし、コードやテンプレート、設定ファイルにアクセスしたい場合は、以下のディレクトリが関係しています。 主に関係するディレクトリ ckan/modelmodel ディレクトリには CKAN の ORM モデル（データベースとのやり取りの仕組み）が含まれています。group.py ファイルには、ユーザグループ（オーガナイゼーションやグループ）のデータ構造が定義されています。 ckan/logic/actionaction ディレクトリには、グループに関連する API やロジックが含まれており、group.py や &gt; organization.py でユーザグループや組織の操作が実装されています。 ckan/templatestemplates フォルダには、ユーザーやグループ情報を表示する HTML テンプレートが含まれており、特に group または organization サブディレクトリが関連するテンプレートです。 データベースとの関連CKAN では、ユーザ、グループ、組織などの情報は PostgreSQL データベース内に格納されます。ユーザグループに関する情報は、主に以下のようなテーブルに保存されています。 group テーブル: グループ情報を格納member テーブル: ユーザとグループの関係を格納 Q. rocky linuxでCKANを一度アンインストールして再度インストールしたところ、アンインストール前のグループ情報等が残っていた。これはなぜか？ A. CKANをアンインストールしても、設定やデータはデータベースとファイルシステムの別の場所に保存されているため、アンインストール前のデータが残っている可能性があります。以下が考えられる理由です。 1.データベースのデータが残っているCKANのデータ（グループ、ユーザ、データセットなど）は、通常 PostgreSQL データベースに保存されています。アンインストールしても、データベース自体やその内容は削除されないため、再インストール時に同じデータベースを参照すると、以前のデータがそのまま残っていることになります。 対策：CKAN のデータベースを削除またはリセットするには、次のような PostgreSQL コマンドを使用してデータベースを削除・再作成する必要があります。 12sudo -u postgres dropdb ckan_defaultsudo -u postgres createdb -O ckan_default ckan_default 2.storage_path ディレクトリが残っているCKAN の設定ファイル（通常 production.ini）で指定されている storage_path は、ファイルアップロード先のディレクトリです。このフォルダ内には、データセットのファイルやリソースが保存されるため、アンインストールしても削除されません。 対策：storage_path のフォルダ（通常 /var/lib/ckan/default など）を手動で削除することで、アップロードされたファイルやキャッシュが削除されます。 3. 設定ファイルの残存CKAN の設定ファイル（例：/etc/ckan/default/production.ini）が残っている場合もあります。このファイルにはデータベース接続情報が含まれているため、再インストール後も同じデータベースに接続することになります。 対策：production.ini ファイルを確認し、再インストールの際に新しい設定ファイルを作成するか、データベース設定を変更してください。 このように、アンインストール後にデータベースやファイルシステムに残っているデータが再インストール時に参照されるため、以前のグループ情報などが残っている可能性が高いです。 別に問題なさそう上記の回答で、CKANが参照しているフォルダの場所がわかった（/etc/ckan/default/や/var/lib/ckan/default など）ので、とりあえず調べるのはここまでにして、何か問題が発生したらもう少し詳しく調べることにした。","link":"/myblog/2024/11/memo-linux-lsof/"},{"title":"SSHローカルポートフォワーディング","text":"プライベートクラウド上の作業をローカルで確認したい時に使うローカルポートフォワーディングについてのメモ。 SSH ローカルポートフォワードとは コマンド 別のポートフォワーディング SSH ローカルポートフォワードとは SSH ローカルポートフォワードとは、SSH の接続を通して、ローカルホストの TCP ポートへの接続をリモートホストの TCP ポートに転送する機能です。ポートフォワーディング、トンネリングと呼ばれたりします。 SSH ローカルポートフォワーディングを利用すると、作業端末から直接接続ができないポートに、SSH により確立された接続を使ってアクセスすることができるようになります。例えば、内部のネットワークのみに公開している Web サイト、データベース、リモートデスクトップに外部から接続したいときなどに使えます。SSH だけ空いていればつながるので、一時的な裏口を作るイメージです。 【参考】SSHローカルポートフォワードの覚え書き（説明がわかりやすい！） コマンド 通常のsshコマンドにLオプション（「Local」の意味）と、繋げたいローカルポート・リモートポートを指定する。 1$ ssh ユーザ名@リモートマシン名 -i .ssh/rsa -L 8080:localhost:80 このとき、 ssh ユーザ名@マシン名は、通常のssh接続 -i .ssh/rsaは、ログインに使う秘密鍵ファイルの指定。 -L 8080:localhost:80は、ローカルポートフォワーディングの設定。これにより、接続元のローカルマシンのポート8080をリモートマシンのlocalhostポート80に転送して、接続が可能になる。 別のポートフォワーディング 他にリモートポートフォワーディング（オプションは-R）、ダイナミックポートフォワーディングがある。 【参考】ssh接続のポートフォワーディングは3種類ある！ が、あまり使わないかも？余裕がある時にまた勉強。 【参考】SSHポートフォワーディング機能のおさらいと利用例","link":"/myblog/2024/11/memo-local-port-forwarding/"},{"title":"ローカルホストのipアドレス、ループバックアドレス","text":"IT LeadersのCADDEの記事を読んでいて理解が足りない箇所があり、調べた際のメモ。 わからなかったこと① 躓いた箇所はこちら。 ここでは、提供者カタログサイトを5000番ポートで起動しているため、ローカルホストのIPアドレスを指定します。なお、ループバックアドレスやlocalhostを使用すると、提供者コネクタを起動するコンテナ自体を指してしまうことに注意が必要です。ローカルホストのIPアドレスは、Linuxであればip aなどのコマンドから確認できます。 ローカルホストのIPアドレスはip aなどのコマンドから確認できる、とあったので確認してみたが、沢山出てきてどれがローカルホストのアドレスだかわからなかった。 調べてわかったこと① Chat-GPT先生に相談しなから調べてみたところ、以下がローカルホストのIPアドレスとのこと。 1inet 127.0.0.1/8 scope host lo これがなぜローカルホストのIPだとわかるか？ 1. IPアドレスの範囲127.0.0.1は、IPv4の「ループバックアドレス」として特別に予約されているアドレス。127.0.0.1/8という範囲（127.0.0.0から127.255.255.255）はすべて、ループバック用途のみに使用され、外部ネットワークと通信せずに、システム内で自身を指すアドレスとして使われる。 ループバックアドレスとは？自分自身を指すIPアドレス。127.0.0.1から127.255.255.255であればいくつでもよい。locakhostも自分自身を指すが、こちらはホスト名のこと。 ネットワークの標準仕様として、127.0.0.1はlocalhostを指すIPアドレスと定義されており、これはシステム間で共有の設定。 【参考】ループバックアドレスとは（記事内の参考リンクも合わせて読むと理解が深まる） 2. インターフェース名が「lo」loは「loopback（ループバック）」の略で、通常どのシステムでも自分自身への通信のための仮想インターフェース（I/F）にこの名前が付けられている。このI/Fは、システムが外部ネットワークを介さずに自分自身と通信するために使用される。 ３. scope hostscope hostは、このアドレスがホスト内にのみ有効であることを示している。外部からアクセスされることはなく、ホスト内の通信にのみ使われる設定。 わからなかったこと② ローカルホストのIPアドレスについてはなんとなくわかってきたが、記事の なお、ループバックアドレスやlocalhostを使用すると、提供者コネクタを起動するコンテナ自体を指してしまうことに注意が必要です。 という文言がよくわからなくなった。 ローカルホストのIPアドレスを指定するけどlocalhostはNG？ 多分わかったこと② 「ローカルホストに振られているIPアドレスのうち、ループバックアドレス（127.0.0.1）やlocalhostが以外のアドレスを指定しましょう」と解釈した。 そのため、職場のプライベートクラウド内で使用しているプライベートネットワークのIPアドレスを指定してみる。","link":"/myblog/2024/11/memo-localhost-ip-and-loopback/"},{"title":"ipコマンドの出力結果（scope、lifetime）","text":"前回の投稿でip aコマンドを見た際、ループバックアドレス以外のアドレスの内容も気になり調べた結果をメモしておく。 例えば、以下のような出力結果について見ていく。 12inet 133.xxx.xxx.xxx/24 brd 133.xxx.xxx.255 scope global noprefixroute enp1s0 valid_lft forever preferred_lft forever scopeについて 前回の投稿ではscope localがローカルホスト内でのみ有効で、外部アクセスはできない設定だと学んだ。 そもそもこのscopeは、IPネットワークの範囲（IPアドレスが有効な範囲、アクセス可能範囲）を表現した概念。 scopeにはlocalのほかにglobal、linkなどの分類がある（IPv4、IPv6によって定義が異なる）。 scope global： グローバルにアクセス可能なアドレス。 例えば、インターネットにアクセスするための133.xxx.xxx.xxxなどのIPv4アドレスなど。 scope link： 同一リンク（ネットワークインターフェース）上でのみ有効なアドレスで、ルータ等のL3中継装置で区切られたセグメント単位を越えることはできない。 主にリンクローカルアドレス（IPv6のfe80::/64範囲など）で使用され、隣接デバイスとの直接通信に使われる。 【参考】スコープという考え方 valid_lftについて valid_lftやpreferred_lftなどはIPアドレスの有効期間（Lifetime）を示している。 valid_lft： Valid_Lifetimeの略で、アドレスが有効である期間を秒数で表示する。 foreverと表示される場合、アドレスの有効期限が無期限であることを表す。 この時間が切れるとそのアドレスは無効になり、システムから削除されることがある。 preferred_lft： Preferred_Lifetimeの略で、アドレスが優先的に使用される期間を示している。 この期間内は、システムが他のアドレスよりもこのアドレスを優先して使う。 出力結果の再見 再度出力結果を見てみる。 12inet 133.xxx.xxx.xxx/24 brd 133.xxx.xxx.255 scope global noprefixroute enp1s0 valid_lft forever preferred_lft forever この例の意味は以下のようになる。 enp1s0：インターフェース名（接続名）scope global：グローバルにアクセス可能であるvalid_lft forever preferred_lft forever：このアドレスは無期限に有効で、優先的に使用される なお、ipコマンドの内容の見方（ifconfigを使う人もいるが非推奨らしい）については、以下の方が素晴らしくまとめて下さっている。ifconfigの出力結果に書いてあること","link":"/myblog/2024/11/memo-scope-lifetime/"},{"title":"勉強用資料","text":"積ん読資料を置いておく。 【最新版】IT系ビジネスマンが読むべき有益資料まとめ 今年もMIXIの23新卒技術研修の資料と動画を公開します！ 【2024年版】MIXI 新卒向け技術研修の資料・動画を公開しました！","link":"/myblog/2024/11/study-docukemts/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/myblog/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/myblog/tags/Icarus/"},{"name":"Git","slug":"Git","link":"/myblog/tags/Git/"},{"name":"ssh","slug":"ssh","link":"/myblog/tags/ssh/"},{"name":"wireguard","slug":"wireguard","link":"/myblog/tags/wireguard/"},{"name":"コマンド","slug":"コマンド","link":"/myblog/tags/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/"},{"name":"TCP&#x2F;IP","slug":"TCP-IP","link":"/myblog/tags/TCP-IP/"},{"name":"参考資料・動画","slug":"参考資料・動画","link":"/myblog/tags/%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99%E3%83%BB%E5%8B%95%E7%94%BB/"}],"categories":[{"name":"blog","slug":"blog","link":"/myblog/categories/blog/"},{"name":"tech","slug":"tech","link":"/myblog/categories/tech/"},{"name":"linux","slug":"linux","link":"/myblog/categories/linux/"},{"name":"network","slug":"network","link":"/myblog/categories/network/"},{"name":"study","slug":"study","link":"/myblog/categories/study/"}],"pages":[]}